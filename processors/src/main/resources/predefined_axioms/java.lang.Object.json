[{"method":"/**\n * Sees the {@link #equals(Object)} method as a congruence relation (smallest\n * equivalence relation that yields full abstraction) for the method\n * {@link #toString()}.\n *\n * This axiom is similar in spirit to the\n * {@link axioms.ObjectAxioms#hashCodeProperty2congruenceEquals(java.lang.Object, java.lang.Object)}\n * axiom which is required by the Java standard library.\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void congruenceToString(Object a, Object b) {\n    try {\n        if (a.equals(b))\n            assertEquals(a.toString(), b.toString(), \"congruenceToString (\" + a.getClass() + \")\" + a.toString() + \", (\" + b.getClass() + \")\" + b.toString());\n    } catch (RuntimeException e) {\n        assertTrue(true, \"some run-time exception occurred\");\n    }\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"},{"method":"/**\n * Sees the {@link #toString()} method as defining the equivalence relation\n * {@link #equals(Object)}: When two objects have the same {@code String}\n * representation they have to be equal objects.\n *\n * For more details on the {@link #equals(Object)} method see the axioms in\n * {@link axioms.ObjectAxioms}.\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void congruenceFromString(Object a, Object b) {\n    try {\n        if (a.toString().equals(b.toString()))\n            assertEquals(a, b, \"congruenceFromString (\" + a.getClass() + \")\" + a.toString() + \", (\" + b.getClass() + \")\" + b.toString());\n    } catch (RuntimeException e) {\n        assertTrue(true, \"some run-time exception occurred\");\n    }\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"},{"method":"/**\n * equals property 1: reflexive.\n * <p>\n * The equals method implements an equivalence relation on non-null object\n * references:<br>\n * It is reflexive: for any non-null reference value x, x.equals(x) should\n * return true.\n *\n * @param x\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void equalsProperty1reflexive(Object x) {\n    if (x != null)\n        assertEquals(x, x, \"Compares (\" + x.getClass() + \")\" + x.toString());\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"},{"method":"/**\n * equals property 2: symmetric.\n * <p>\n * The equals method implements an equivalence relation on non-null object\n * references:<br>\n * It is symmetric: for any non-null reference values x and y, x.equals(y)\n * should return true if and only if y.equals(x) returns true\n *\n * @param x\n * @param y\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void equalsProperty2symmetric(Object x, Object y) {\n    if (x != null && y != null)\n        assertEquals(x.equals(y), y.equals(x), \"Compares (\" + x.getClass() + \")\" + x.toString() + \" (\" + y.getClass() + \")\" + y.toString());\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"},{"method":"/**\n * equals property 3: transitive.\n * <p>\n * The equals method implements an equivalence relation on non-null object\n * references:<br>\n * It is transitive: for any non-null reference values x, y, and z, if\n * x.equals(y) returns true and y.equals(z) returns true, then x.equals(z)\n * should return true.\n *\n * @param x\n * @param y\n * @param z\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void equalsProperty3transitive(Object x, Object y, Object z) {\n    if (x != null && y != null && z != null)\n        if (x.equals(y) && y.equals(z))\n            assertEquals(x, z, \"Compares (\" + x.getClass() + \")\" + x.toString() + \" (\" + y.getClass() + \")\" + y.toString() + \" (\" + z.getClass() + \")\" + z.toString());\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"},{"method":"/**\n * equals property 5: comparison to null.\n * <p>\n * The equals method implements an equivalence relation on non-null object\n * references:<br>\n * For any non-null reference value x, x.equals(null) should return false.\n *\n * @param x\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void equalsProperty5null(Object x) {\n    if (x != null)\n        assertFalse(x.equals(null), \"Compares (\" + x.getClass() + \")\" + x.toString());\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"},{"method":"/**\n * hashCode property 1: behaves like a deterministic function.\n * <p>\n * Whenever it is invoked on the same object more than once during an execution\n * of a Java application, the hashCode method must consistently return the same\n * integer, provided no information used in equals comparisons on the object is\n * modified. This integer need not remain consistent from one execution of an\n * application to another execution of the same application.\n *\n * @param a Object that should not be modified\n * @param r number of times to repeat check of hashCode\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void hashCodeProperty1function(Object a, int r) {\n    int h = a.hashCode();\n    for (int i = 0; i < r; i++) {\n        // assuming a remains unchanged wrt method equals()\n        assertEquals(h, a.hashCode(), \"Checks \" + i + \" out of \" + r + \" times (\" + a.getClass() + \")\" + a.toString());\n    }\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"},{"method":"/**\n * hashCode property 2: equals is a congruence relation wrt. hashCode.\n * <p>\n * If two objects are equal according to the equals(Object) method, then calling\n * the hashCode method on each of the two objects must produce the same integer\n * result.\n */\n@AxiomForExistingClass(className = \"java.lang.Object\")\npublic static void hashCodeProperty2congruenceEquals(Object a, Object b) {\n    if (a == null)\n        return;\n    if (a.equals(b))\n        assertEquals(a.hashCode(), b.hashCode(), \"Checks (\" + a.getClass() + \")\" + a.toString() + \" (\" + b.getClass() + \")\" + b.toString());\n}","isGeneric":true,"qualifiedClassName":"java.lang.Object"}]