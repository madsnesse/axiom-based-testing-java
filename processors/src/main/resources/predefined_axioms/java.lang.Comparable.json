[{"method":"/**\n * The implementor must ensure {@code signum(x.compareTo(y)) == -signum(y.compareTo(x))} for all {@code x} and {@code y}.\n * (This implies that {@code x.compareTo(y)} must throw an exception if and only if {@code y.compareTo(x)} throws an exception.)\n */\n@AxiomForExistingClass(className = \"java.lang.Comparable\")\npublic static <T extends Comparable<T>> void compareToConsistentWithSignum(T x, T y) {\n    try {\n        var left = x.compareTo(y);\n        var right = y.compareTo(x);\n        assertEquals(Integer.signum(left), -Integer.signum(right));\n    } catch (RuntimeException e) {\n        try {\n            y.compareTo(x);\n            assertEquals(1, 0);\n        } catch (RuntimeException e2) {\n            assertEquals(1, 1);\n        }\n    }\n}","isGeneric":true,"qualifiedClassName":"java.lang.Comparable"},{"method":"/**\n * The implementor must also ensure that the relation is transitive:\n * {@code (x.compareTo(y) > 0 && y.compareTo(z) > 0)} implies {@code x.compareTo(z) > 0}.\n */\n@AxiomForExistingClass(className = \"java.lang.Comparable\")\npublic static <T extends Comparable<T>> void compareToTransitive(T x, T y, T z) {\n    if (x.compareTo(y) > 0 && y.compareTo(z) > 0) {\n        assertTrue(x.compareTo(z) > 0);\n    }\n}","isGeneric":true,"qualifiedClassName":"java.lang.Comparable"},{"method":"/**\n * It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)).//TODO create support for recommended axioms\n * Generally speaking, any class that implements the Comparable interface\n * and violates this condition should clearly indicate this fact. The recommended language is\n * \"Note: this class has a natural ordering that is inconsistent with equals.\"\n */\n@AxiomForExistingClass(className = \"java.lang.Comparable\")\npublic static <T extends Comparable<T>> void compareToEqualsConsistent(T x, T y) {\n    assertEquals(x.compareTo(y) == 0, x.equals(y));\n}","isGeneric":true,"qualifiedClassName":"java.lang.Comparable"}]